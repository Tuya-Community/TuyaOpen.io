"use strict";(self.webpackChunktuyaopen_io_website=self.webpackChunktuyaopen_io_website||[]).push([["6258"],{73342:function(e,n,i){i.r(n),i.d(n,{frontMatter:()=>d,toc:()=>l,default:()=>u,metadata:()=>t,assets:()=>s,contentTitle:()=>o});var t=JSON.parse('{"id":"peripheral/audio","title":"Audio Driver","description":"Introduction","source":"@site/docs/peripheral/audio.md","sourceDirName":"peripheral","slug":"/peripheral/audio","permalink":"/docs/peripheral/audio","draft":false,"unlisted":false,"editUrl":"https://github.com/Tuya-Community/TuyaOpen.io/edit/master/docs/peripheral/audio.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Display Driver","permalink":"/docs/peripheral/display"},"next":{"title":"Button Driver","permalink":"/docs/peripheral/button"}}'),a=i(74848),r=i(84429);let d={},o="Audio Driver",s={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Prerequisite Concepts",id:"prerequisite-concepts",level:2},{value:"Audio Connection Framework",id:"audio-connection-framework",level:2},{value:"Hardware Framework for Audio Devices with Built-in CODEC",id:"hardware-framework-for-audio-devices-with-built-in-codec",level:3},{value:"Hardware Framework for Audio Devices with External CODEC",id:"hardware-framework-for-audio-devices-with-external-codec",level:3},{value:"Functional Modules",id:"functional-modules",level:2},{value:"Abstract Management Module: TDL (Tuya Driver Layer)",id:"abstract-management-module-tdl-tuya-driver-layer",level:3},{value:"Instantiation and Registration Module: TDD (Tuya Device Driver)",id:"instantiation-and-registration-module-tdd-tuya-device-driver",level:3},{value:"Feature Introduction",id:"feature-introduction",level:2},{value:"Supported Peripherals List",id:"supported-peripherals-list",level:2},{value:"Workflow",id:"workflow",level:2},{value:"Development Guide",id:"development-guide",level:2},{value:"Kconfig Configuration",id:"kconfig-configuration",level:3},{value:"Runtime Environment",id:"runtime-environment",level:3},{value:"Target Board Default Enabled",id:"target-board-default-enabled",level:4},{value:"Enabled a feature that requires the audio driver",id:"enabled-a-feature-that-requires-the-audio-driver",level:4},{value:"Manually enable the macro",id:"manually-enable-the-macro",level:4},{value:"How to Use",id:"how-to-use",level:3},{value:"Adapting the Audio Driver",id:"adapting-the-audio-driver",level:4},{value:"Registering the Audio Device",id:"registering-the-audio-device",level:4},{value:"Controlling the Device",id:"controlling-the-device",level:4},{value:"API Reference",id:"api-reference",level:2},{value:"Audio Device Configuration Structure",id:"audio-device-configuration-structure",level:3},{value:"Audio Driver Registration Structure",id:"audio-driver-registration-structure",level:3},{value:"Audio Device Registration Interface",id:"audio-device-registration-interface",level:3},{value:"Audio Driver Registration Interface",id:"audio-driver-registration-interface",level:3},{value:"Device Find and Management Interface",id:"device-find-and-management-interface",level:3},{value:"Device Open Interface",id:"device-open-interface",level:3},{value:"Device Close Interface",id:"device-close-interface",level:3},{value:"Volume Adjustment Interface",id:"volume-adjustment-interface",level:3},{value:"Audio Playback Control Interface",id:"audio-playback-control-interface",level:3},{value:"Audio Stop Playback Interface",id:"audio-stop-playback-interface",level:3}];function c(e){let n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"audio-driver",children:"Audio Driver"})}),"\n",(0,a.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.a,{href:"https://github.com/tuya/TuyaOpen/tree/master/src/peripherals/audio_codecs",children:"Audio Driver"})," is a core component in TuyaOpen used for handling audio input and output. It provides a unified interface to manage different types of audio devices, such as microphones and speakers. Through this driver, applications can easily perform audio capture, playback, and configuration without needing to be concerned with the specific implementation details of the underlying hardware."]}),"\n",(0,a.jsx)(n.h2,{id:"prerequisite-concepts",children:"Prerequisite Concepts"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Term"}),(0,a.jsx)(n.th,{style:{textAlign:"left"},children:"Explanation"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"MIC(Microphone)"}),(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"A microphone is a transducer that converts sound signals into electrical signals."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"SPK(Speaker)"}),(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"A speaker is a device that converts electrical signals into sound signals."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"CODEC(Codec)"}),(0,a.jsxs)(n.td,{style:{textAlign:"left"},children:["A CODEC typically consists of two main parts:",(0,a.jsx)("br",{}),(0,a.jsx)(n.strong,{children:"Encoder"})," Converts raw data (like uncompressed audio or video) into another format for easier storage or transmission.",(0,a.jsx)("br",{}),(0,a.jsx)(n.strong,{children:"Decoder"})," Restores the encoded data to its original format for viewing or playback."]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"PA(Power Amplifier)"}),(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"A PA is an electronic device whose main function is to amplify the power of a weak input signal so that it can drive a larger load, such as a speaker or antenna."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"PCM"}),(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"PCM is a method of encoding analog audio signals into digital signals. The raw PCM data (often called a PCM stream or raw data) is uncompressed and needs to be decoded before it can be played."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"PDM"}),(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"PDM is also a digital audio encoding method, characterized by having only one bit of data, using the density of pulses to represent the intensity of the analog signal."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"I2C"}),(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"Primarily used for control signals, configuration parameters, and small amounts of data transfer between chips, using two lines for communication: SDA (Serial Data) and SCL (Serial Clock)."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"I2S"}),(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"Specifically used for the transmission of digital audio data, using at least three lines, including SCK (Serial Clock), WS (Word Select), and SD (Serial Data)."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"ADC"}),(0,a.jsxs)(n.td,{style:{textAlign:"left"},children:["Converts analog signals (such as sound, light, temperature, etc.) into digital signals for processing, storage, and transmission by computers or other digital systems. The ",(0,a.jsx)(n.code,{children:"AD"})," conversion process typically includes three steps: sampling, quantization, and encoding (such as PCM encoding)."]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"DAC"}),(0,a.jsxs)(n.td,{style:{textAlign:"left"},children:["Converts digital signals (from computers, MP3 players, etc.) into analog signals to drive analog devices such as speakers and displays. The ",(0,a.jsx)(n.code,{children:"DA"})," conversion process typically generates a corresponding analog voltage or current output based on the value of the digital signal."]})]})]})]}),"\n",(0,a.jsx)(n.h2,{id:"audio-connection-framework",children:"Audio Connection Framework"}),"\n",(0,a.jsxs)(n.p,{children:["The audio connection framework varies depending on the main control chip. For example, the ",(0,a.jsx)(n.code,{children:"T5AI"})," has built-in ADC and DAC interfaces and can implement an audio system without a CODEC chip. In contrast, the ",(0,a.jsx)(n.code,{children:"ESP32-S3"})," does not support DAC and requires an external CODEC chip to build an audio system."]}),"\n",(0,a.jsx)(n.h3,{id:"hardware-framework-for-audio-devices-with-built-in-codec",children:"Hardware Framework for Audio Devices with Built-in CODEC"}),"\n",(0,a.jsx)(n.mermaid,{value:'graph LR\nsubgraph mic ["Microphone"]\nmicrophone[" Microphone "]\nend\n\nsubgraph esp32 ["MCU"]\nesp_adc["ADC"]\nesp_dac["DAC"]\npa_gpio["PA_GPIO"]\nend\n\nsubgraph ns4150 ["PA"]\nns_in["IN"]\namp["AMP"]\nns_out["OUT"]\nns_ctrl["CTRL"]\n\n%% PA internal connection\nns_in --\x3e amp\namp --\x3e ns_out\nend\n\nsubgraph speaker_box ["Speaker"]\nspeaker["Speaker"]\nend\n\nmicrophone --\x3e|"ADC Capture audio signals"| esp_adc\nesp_dac --\x3e|"DAC Output audio signal"| ns_in\nns_out --\x3e|"Audio output"| speaker\npa_gpio --\x3e|"Control signals"| ns_ctrl\n'}),"\n",(0,a.jsx)(n.h3,{id:"hardware-framework-for-audio-devices-with-external-codec",children:"Hardware Framework for Audio Devices with External CODEC"}),"\n",(0,a.jsx)(n.mermaid,{value:'graph LR\nsubgraph mic [" Microphone "]\nmicrophone["Microphone"]\nend\n\nsubgraph codec [" CODEC "]\nadc["ADC"]\ndac["DAC"]\ni2s_port["I2S"]\ni2c_port["I2C"]\n\n%% CODEC internal connection\nadc --\x3e|"Data channels"| i2s_port\ni2s_port --\x3e|"Data channels"| dac\nend\n\nsubgraph mcu [" MCU "]\ni2s_bus["I2S"]\ni2c_bus["I2C"]\npa_gpio["PA_GPIO"]\nend\n\nsubgraph amplifier [" PA "]\nns_in["IN"]\namp["AMP"]\nns_out["OUT"]\nns_ctrl["CTRL"]\n\n%% PA internal connection\nns_in --\x3e amp\namp --\x3e ns_out\nend\n\nsubgraph speaker_box ["Speaker"]\nspeaker["Speaker"]\nend\n\nmicrophone --\x3e|"ADC Capture audio signals"| adc\ndac --\x3e|"DAC Output audio signal"| ns_in\ni2c_bus --\x3e|"I2C communication"| i2c_port\ni2s_bus --\x3e|"I2S Data (PCM coded)"| i2s_port\nns_out --\x3e|"Audio output"| speaker\npa_gpio --\x3e|"Control signals"| ns_ctrl\n'}),"\n",(0,a.jsx)(n.h2,{id:"functional-modules",children:"Functional Modules"}),"\n",(0,a.jsx)(n.p,{children:"TuyaOpen aims to provide a standardized, platform-independent audio solution with a core design philosophy of layered decoupling. It separates the application layer's audio requirements from the underlying specific hardware implementation."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"For Application Developers"}),": Regardless of whether the underlying chip is a T5AI or another audio codec, the application layer only needs to call a unified, standardized set of APIs (the tdl_audio_xxx series of functions), such as tdl_audio_open, tdl_audio_play, etc. This greatly reduces the complexity of application development and improves code portability."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"For Driver Developers"}),": When a new audio chip needs to be supported, one only needs to follow the standard interface defined in ",(0,a.jsx)(n.code,{children:"tdl_audio_driver.h"})," to write a new TDD layer driver (similar to ",(0,a.jsx)(n.code,{children:"tdd_audio.c"}),") and register it with the TDL management layer, without modifying any application layer code."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"abstract-management-module-tdl-tuya-driver-layer",children:"Abstract Management Module: TDL (Tuya Driver Layer)"}),"\n",(0,a.jsx)(n.p,{children:"This is the highest level of abstraction, providing a unified audio service interface to the application layer."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"tdl_audio_manage.c/h: Implements the core of audio driver management. It maintains a linked list for registering and managing different types (or different platforms) of audio device drivers. Applications use audio functions by calling tdl_audio_find, tdl_audio_open, etc., without needing to know the underlying implementation details."}),"\n",(0,a.jsx)(n.li,{children:'tdl_audio_driver.h: Defines the "standardized interface" (TDD_AUDIO_INTFS_T) that all audio device drivers must adhere to, including function pointers for open, play, config, close, etc. This ensures that tdl_audio_manage can uniformly call any underlying driver that conforms to this standard.'}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"instantiation-and-registration-module-tdd-tuya-device-driver",children:"Instantiation and Registration Module: TDD (Tuya Device Driver)"}),"\n",(0,a.jsx)(n.p,{children:"This is the middle layer of the driver, representing the specific implementation for a particular hardware platform."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"tdd_audio.c/h: Implements the audio driver for different platforms. It is responsible for connecting the upper and lower layers, implementing the TDD_AUDIO_INTFS_T standard interface defined by TDL, and calling the TKL layer or the original manufacturer's hardware abstraction interface to control the actual hardware. The tdd_audio_register function registers this driver's implementation (function pointers) with the TDL layer."}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"feature-introduction",children:"Feature Introduction"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"a. Audio Input (Microphone Capture)"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Start and Stop"}),": Audio capture can be started and stopped using tdl_audio_open and tdl_audio_close."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Asynchronous Data Callback"}),": The driver uses a callback mechanism (TDL_AUDIO_MIC_CB) to push the captured audio data to the application layer frame by frame in real-time. The application layer does not need to actively read the data but passively receives it, which is more efficient."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Status Notification"}),': The callback function not only transmits audio data but also the current status (TDL_AUDIO_STATUS_E), for example, it can notify the application of "Voice Activity Detected (VAD_START)" or "Voice Activity Ended (VAD_END)".']}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"b. Audio Output (Speaker Playback)"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Play Audio Stream"}),": The application layer can send audio data blocks in formats like PCM to the driver for playback by calling the tdl_audio_play function."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Control Playback"}),": The tdl_audio_play_stop function can be called at any time to clear the playback buffer and immediately stop the currently playing audio."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"c. Volume Control"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Set Volume"}),": The playback volume of the speaker can be dynamically adjusted at runtime (range 0-100) using the tdl_audio_volume_set function."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"d. Echo Cancellation (AEC) Support"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Configurable AEC"}),": When initializing the audio device, you can choose to enable or disable the acoustic echo cancellation function (requires hardware support) through a configuration option (aec_enable)."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Improved Call Experience"}),": AEC is a key technology for achieving full-duplex voice calls (i.e., speaking and listening at the same time without producing echo). This driver has built-in support for AEC, enabling it to meet the needs of advanced applications such as voice intercom and video calls."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"e. Extensible Driver Management"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Dynamic Registration and Discovery"}),": The system can register multiple different audio drivers simultaneously (e.g., an onboard Codec, an external USB sound card)."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Find by Name"}),': The application layer can find and obtain a handle to a specific audio device (tdl_audio_find) using a string name (e.g., "audio_codec"), enabling flexible device selection.']}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"supported-peripherals-list",children:"Supported Peripherals List"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{style:{textAlign:"center"},children:"CODEC"}),(0,a.jsx)(n.th,{style:{textAlign:"center"},children:"Recording"}),(0,a.jsx)(n.th,{style:{textAlign:"center"},children:"Playback"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"center"},children:"ES8311"}),(0,a.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"}),(0,a.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"center"},children:"ES8388"}),(0,a.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"}),(0,a.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"center"},children:"ES8389"}),(0,a.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"}),(0,a.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"center"},children:"\xb7\xb7\xb7"}),(0,a.jsx)(n.td,{style:{textAlign:"center"}}),(0,a.jsx)(n.td,{style:{textAlign:"center"}})]})]})]}),"\n",(0,a.jsx)(n.h2,{id:"workflow",children:"Workflow"}),"\n",(0,a.jsx)(n.p,{children:"Taking T5AI as an example, this section introduces the workflow of the audio driver framework."}),"\n",(0,a.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant App as Application\n    participant TAL as Audio Abstraction Layer\n    participant TDD as Audio Device Driver\n    participant Bd as Board-level Configuration\n\n    Note over App, Bd: Register Audio Device\n    \n    Bd->>+TDD: Call tdd_audio_register\n    Note right of Bd: Pass AUDIO_CODEC_NAME<br/>Pass TDD_AUDIO_T5AI_T config parameters<br/>- ai_chn: TKL_AI_0<br/>- sample_rate: TKL_AUDIO_SAMPLE_16K<br/>- data_bits: TKL_AUDIO_DATABITS_16<br/>- channel: TKL_AUDIO_CHANNEL_MONO<br/>- spk_pin: BOARD_SPEAKER_EN_PIN<br/>- aec_enable: 0/1\n    \n    TDD->>+TAL: Call tdl_audio_driver_register\n    Note right of TDD: Register device name<br/>Register audio interface (TDD_AUDIO_INTFS_T)<br/>- __tdd_audio_open<br/>- __tdd_audio_close<br/>- __tdd_audio_play<br/>- __tdd_audio_config<br/>- __tdd_audio_set_volume\n    \n    Note over TAL: Create audio node (TDL_AUDIO_NODE_T)<br/>Add node to audio list (__audio_node_add)\n    \n    TAL--\x3e>-TDD: Return registration result\n    TDD--\x3e>-Bd: Return registration result\n\n    Note over App, Bd: Get Audio Device Handle\n    \n    App->>+TAL: Call tdl_audio_find\n    Note over TAL: Find audio device in the list by device name<br/>Return audio node handle\n    TAL--\x3e>-App: Return audio device handle\n\n    Note over App, Bd: Open Audio Device\n    \n    App->>+TAL: Call tdl_audio_open\n    TAL->>+TDD: Call __tdd_audio_open\n    Note right of TDD: Initialize audio hardware<br/>Configure ADC/DAC parameters<br/>Set I2S interface<br/>Configure speaker enable pin\n    TDD--\x3e>-TAL: Return open result\n    TAL--\x3e>-App: Return device open result\n\n    Note over App, Bd: Configure Audio Parameters\n    \n    App->>+TAL: Call audio configuration interface\n    TAL->>+TDD: Call __tdd_audio_config\n    Note right of TDD: Set sample rate<br/>Set data bits<br/>Set channel configuration<br/>Configure echo cancellation (if enabled)\n    TDD--\x3e>-TAL: Return configuration result\n    TAL--\x3e>-App: Return configuration result\n\n    Note over App, Bd: Set Volume\n    \n    App->>+TAL: Call tdl_audio_volume_set\n    TAL->>+TDD: Call __tdd_audio_set_volume\n    Note right of TDD: Adjust audio output volume<br/>Control speaker power amplifier\n    TDD--\x3e>-TAL: Return volume setting result\n    TAL--\x3e>-App: Return volume setting result\n\n    Note over App, Bd: Play Audio\n    \n    App->>+TAL: Call tdl_audio_play\n    Note right of App: Pass audio frame data<br/>Pass frame format (TDL_AUDIO_FRAME_FORMAT_E)\n    TAL->>+TDD: Call __tdd_audio_play\n    TAL->>TDD: Call __tkl_audio_frame_put\n    Note right of TDD: Process audio frame data<br/>Output to DAC/I2S<br/>Control speaker enable\n    TDD--\x3e>-TAL: Return playback result\n    TAL--\x3e>-App: Return playback result\n\n    Note over App, Bd: Stop Audio Playback\n    \n    App->>+TAL: Call tdl_audio_play_stop\n    TAL->>+TDD: Stop audio playback\n    Note right of TDD: Stop audio output<br/>Disable speaker\n    TDD--\x3e>-TAL: Return stop result\n    TAL--\x3e>-App: Return stop result\n\n    Note over App, Bd: Close Audio Device\n    \n    App->>+TAL: Call tdl_audio_close\n    TAL->>+TDD: Call __tdd_audio_close\n    Note right of TDD: De-initialize audio hardware<br/>Release I2S resources<br/>Disable speaker pin\n    TDD--\x3e>-TAL: Return close result\n    TAL--\x3e>-App: Return device close result\n"}),"\n",(0,a.jsx)(n.h2,{id:"development-guide",children:"Development Guide"}),"\n",(0,a.jsx)(n.h3,{id:"kconfig-configuration",children:"Kconfig Configuration"}),"\n",(0,a.jsxs)(n.p,{children:["To include the driver in the build, you need to check if the relevant Kconfig options are enabled before compiling. In the target project path, execute ",(0,a.jsx)(n.code,{children:"tos.py config menu"})," in the terminal to view the following configuration options."]}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{style:{textAlign:"left"},children:"Configuration Macro"}),(0,a.jsx)(n.th,{style:{textAlign:"left"},children:"Type"}),(0,a.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"enable audio codecs"}),(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"Boolean"}),(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"The driver code will only be compiled if this macro is enabled."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"audio support AEC"}),(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"Boolean"}),(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"Enable AEC function (requires hardware support)."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"the name of audio codec"}),(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"String"}),(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"Configure the device name of the CODEC."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"the num of audio codecs"}),(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"Integer"}),(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"Configure the number of board-level CODECs."})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"open_audio",src:i(31599).A+"",width:"681",height:"274"})}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["The above configuration items must be supported in ",(0,a.jsx)(n.code,{children:"src/peripherals/audio_codecs/Kconfig"})," and ",(0,a.jsx)(n.code,{children:"boards/<target_platform>/<target_board>/Kconfig"})," (check the Kconfig file for your target board). If you do not find the relevant configuration items, please check the contents of these two files."]})}),"\n",(0,a.jsx)(n.h3,{id:"runtime-environment",children:"Runtime Environment"}),"\n",(0,a.jsxs)(n.p,{children:["To run this driver, you need to first enable the ",(0,a.jsx)(n.strong,{children:"main enable macro"})," ",(0,a.jsx)(n.code,{children:"<ENABLE_AUDIO_CODECS>"}),". There are three ways to enable this macro: ",(0,a.jsx)(n.strong,{children:"Board default enabled"}),", ",(0,a.jsx)(n.strong,{children:"enabled a feature that requires the screen driver"}),", and ",(0,a.jsx)(n.strong,{children:"manually enabled"}),"."]}),"\n",(0,a.jsx)(n.admonition,{type:"warning",children:(0,a.jsx)(n.p,{children:"All the following commands need to be executed in the target application directory. Do not execute them directly in the TuyaOpen root directory or other directories, otherwise an error will be reported."})}),"\n",(0,a.jsx)(n.h4,{id:"target-board-default-enabled",children:"Target Board Default Enabled"}),"\n",(0,a.jsxs)(n.admonition,{type:"info",children:[(0,a.jsx)(n.p,{children:"In this case, the developer's chosen development board has usually already registered the screen device. At this time, the source file in the target Board has already written the registration code."}),(0,a.jsxs)(n.p,{children:["For example, the TUYA_T5AI_EVB development board supports a microphone and speaker. When adapting this board, the audio device has already been registered, and the ",(0,a.jsx)(n.code,{children:"boards/T5AI/TUYA_T5AI_EVB/Kconfig"})," file will also have ",(0,a.jsx)(n.code,{children:"select ENABLE_AUDIO_CODECS"}),". (For specific example code and configuration, please refer to ",(0,a.jsx)(n.code,{children:"boards/T5AI/TUYA_T5AI_EVB"}),")."]})]}),"\n",(0,a.jsx)(n.p,{children:"This means that as long as the developer selects the corresponding target Board, the driver will be automatically enabled."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Execute the command to enter the Kconfig menu"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-shell",children:"tos.py config menu\n"})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.admonition,{type:"warning",children:(0,a.jsxs)(n.p,{children:["After executing ",(0,a.jsx)(n.code,{children:"select ENABLE_XXX"})," in boards/T5AI/TUYA_T5AI_EVB/Kconfig, you cannot manually select/deselect it by executing ",(0,a.jsx)(n.code,{children:"tos.py config menu"}),"."]})}),"\n",(0,a.jsx)(n.h4,{id:"enabled-a-feature-that-requires-the-audio-driver",children:"Enabled a feature that requires the audio driver"}),"\n",(0,a.jsx)(n.p,{children:"If the developer selects a feature that depends on the audio driver, the enable macro for the audio driver will also be automatically enabled."}),"\n",(0,a.jsx)(n.h4,{id:"manually-enable-the-macro",children:"Manually enable the macro"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Execute the command to enter the Kconfig menu"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-shell",children:"tos.py config menu\n"})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Enable the driver enable macro"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"open_audio",src:i(31599).A+"",width:"681",height:"274"})}),"\n",(0,a.jsx)(n.h3,{id:"how-to-use",children:"How to Use"}),"\n",(0,a.jsx)(n.h4,{id:"adapting-the-audio-driver",children:"Adapting the Audio Driver"}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["Developers can skip this step if they find a corresponding driver in ",(0,a.jsx)(n.a,{href:"https://github.com/tuya/TuyaOpen/tree/master/boards/ESP32/common/audio",children:"tdd_audio"}),". If you cannot find a suitable audio driver for yourself, you can adapt the driver yourself."]})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Create ",(0,a.jsx)(n.code,{children:"tdd_audio_xxx.c/h"})," files in ",(0,a.jsx)(n.code,{children:"src/peripherals/audio_codecs/tdd_audio"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Allocate memory"})," for the device and adapt the abstract interface of the audio driver (function pointers such as open, close, play, config, etc.) according to your device."]}),"\n",(0,a.jsxs)(n.li,{children:["Call the ",(0,a.jsx)(n.strong,{children:"register common audio device node"})," interface (tdl_audio_driver_register())."]}),"\n",(0,a.jsx)(n.li,{children:"For example code, please refer to the already adapted drivers."}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"OPERATE_RET tdd_audio_register(char *name, TDD_AUDIO_T5AI_T cfg)\n{\n    OPERATE_RET rt = OPRT_OK;\n    \n    TDD_AUDIO_DATA_HANDLE_T *_hdl = NULL;\n    TDD_AUDIO_INTFS_T intfs = {0};\n\n    /* Allocate memory to the device */\n    _hdl = (TDD_AUDIO_DATA_HANDLE_T *)tal_malloc(sizeof(TDD_AUDIO_DATA_HANDLE_T));\n    memset(_hdl, 0, sizeof(TDD_AUDIO_DATA_HANDLE_T));\n    g_tdd_audio_hdl = _hdl;\n    _hdl->play_volume = 80;\n    memcpy(&_hdl->cfg, &cfg, sizeof(TDD_AUDIO_T5AI_T));\n\n    /* Register function pointers */\n    intfs.open = __tdd_audio_open;\n    intfs.play = __tdd_audio_play;\n    intfs.config = __tdd_audio_config;\n    intfs.close = __tdd_audio_close;\n\n    tdl_audio_driver_register(name, &intfs, (TDD_AUDIO_HANDLE_T)_hdl);\n    return rt;\n}\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"warning",children:(0,a.jsxs)(n.p,{children:["When adapting for ESP32, you need to create new files in the ",(0,a.jsx)(n.code,{children:"boards/ESP32/common/audio"})," path. The CODEC chips that have been adapted for ESP32 are also in this path."]})}),"\n",(0,a.jsx)(n.h4,{id:"registering-the-audio-device",children:"Registering the Audio Device"}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["If the developer's chosen target Board has already registered the audio device, they only need to select the target board in Kconfig and call the ",(0,a.jsx)(n.code,{children:"board_register_hardware()"})," interface in the application. This interface has already registered the corresponding audio device."]})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Write the registration interface according to the developer's audio CODEC model and connection pins. It is recommended to write it in ",(0,a.jsx)(n.code,{children:"board_register_hardware()"}),", the implementation path of this interface is ",(0,a.jsx)(n.code,{children:"boards/<target_platform>/<target_board>/xxx.c"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Configure the basic information of the device and call the registration interface in ",(0,a.jsx)(n.code,{children:"board_register_hardware()"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"OPERATE_RET __board_register_audio(void)\n{\n    /* Write your struct configuration information here */\n    /* begin */\n    \n    /* end */\n    TUYA_CALL_ERR_RETURN(tdd_audio_register(AUDIO_CODEC_NAME, cfg));\n    return rt;\n}\n\nOPERATE_RET board_register_hardware(void)\n{\n	TUYA_CALL_ERR_LOG(__board_register_audio());\n	return rt;\n}\n"})}),"\n",(0,a.jsx)(n.h4,{id:"controlling-the-device",children:"Controlling the Device"}),"\n",(0,a.jsxs)(n.p,{children:["Control the audio device according to the tdl layer interface provided in ",(0,a.jsx)(n.code,{children:"src/peripherals/audio_codecs/tdl_audio/include/tdl_audio_manage.h"}),"."]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Find the device handle by device name"}),"\n",(0,a.jsx)(n.li,{children:"Open and initialize the audio device"}),"\n",(0,a.jsx)(n.li,{children:"Close the audio device and release related resources"}),"\n",(0,a.jsx)(n.li,{children:"Dynamically adjust the audio output volume"}),"\n",(0,a.jsx)(n.li,{children:"Play audio data"}),"\n",(0,a.jsx)(n.li,{children:"Stop playing audio data"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["For specific examples, please refer to ",(0,a.jsx)(n.code,{children:"examples/multimedia/audio"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,a.jsx)(n.h3,{id:"audio-device-configuration-structure",children:"Audio Device Configuration Structure"}),"\n",(0,a.jsx)(n.p,{children:"Taking T5AI as an example, construct the TDD layer hardware configuration information structure."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"/**\n * @brief Audio device configuration structure for T5AI board.\n * \n * This structure contains all hardware configuration parameters for the audio device,\n * including sample rate, data bits, channels, speaker control pins, and AEC settings.\n */\ntypedef struct {\n    uint8_t aec_enable;\n    TKL_AI_CHN_E ai_chn;\n    TKL_AUDIO_SAMPLE_E sample_rate;\n    TKL_AUDIO_DATABITS_E data_bits;\n    TKL_AUDIO_CHANNEL_E channel;\n\n    // spk\n    TKL_AUDIO_SAMPLE_E spk_sample_rate;\n    int spk_pin;\n    int spk_pin_polarity;\n} TDD_AUDIO_T5AI_T;\n"})}),"\n",(0,a.jsx)(n.h3,{id:"audio-driver-registration-structure",children:"Audio Driver Registration Structure"}),"\n",(0,a.jsx)(n.p,{children:"To register the audio driver structure, developers need to implement the corresponding function pointers according to their own audio driver."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"/**\n * @brief Audio driver interface structure.\n * \n * This structure contains function pointers for all audio operations, providing\n * a unified interface for the audio abstract layer to call driver functions.\n */\ntypedef struct {\n    OPERATE_RET (*open)(TDD_AUDIO_HANDLE_T handle, TDL_AUDIO_MIC_CB mic_cb);\n    OPERATE_RET (*play)(TDD_AUDIO_HANDLE_T handle, uint8_t *data, uint32_t len);\n    OPERATE_RET (*config)(TDD_AUDIO_HANDLE_T handle, TDD_AUDIO_CMD_E cmd, void *args);\n    OPERATE_RET (*close)(TDD_AUDIO_HANDLE_T handle);\n} TDD_AUDIO_INTFS_T;\n"})}),"\n",(0,a.jsx)(n.h3,{id:"audio-device-registration-interface",children:"Audio Device Registration Interface"}),"\n",(0,a.jsx)(n.p,{children:"This interface is used to register the audio device driver with the system and is the entry point of the audio driver framework. By passing in the device name and configuration parameters, the audio device is added to the management list for use by the application."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"/**\n * @brief Registers an audio device driver with the audio management system.\n * \n * This function registers an audio device driver including device name, hardware \n * configuration parameters, and driver interface functions. After successful \n * registration, applications can find and use the audio device by name.\n * \n * @param name Audio device name used for identification and lookup\n * @param cfg Audio device configuration parameters including sample rate, data bits, \n *            channels, speaker pin configuration, etc.\n * \n * @return Returns OPRT_OK on successful registration, or an appropriate error code on failure.\n */\nOPERATE_RET tdd_audio_register(const char *name, TDD_AUDIO_T5AI_T cfg);\n"})}),"\n",(0,a.jsx)(n.h3,{id:"audio-driver-registration-interface",children:"Audio Driver Registration Interface"}),"\n",(0,a.jsx)(n.p,{children:"This interface registers the underlying audio driver interface with the abstraction layer management system, creates device nodes, and maintains the device list."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"/**\n * @brief Registers audio device driver interfaces to the abstract layer management system.\n * \n * This function registers audio device driver interface functions to the audio abstract \n * layer management system, creates device nodes and adds them to the device management list \n * for upper layer application calls.\n * \n * @param name Audio device name\n * @param intfs Audio driver interface structure containing various operation function pointers\n * \n * @return Returns OPRT_OK on successful registration, or an appropriate error code on failure.\n */\nOPERATE_RET tdl_audio_driver_register(const char *name, TDD_AUDIO_INTFS_T *intfs);\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"device-find-and-management-interface",children:"Device Find and Management Interface"}),"\n",(0,a.jsx)(n.p,{children:"This interface finds the corresponding device handle in the registered audio device list according to the device name, and is the key interface for obtaining device control."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"/**\n * @brief Finds an audio device by device name.\n * \n * This function searches for the corresponding audio device node in the registered \n * audio device list based on the device name, and returns a device handle for \n * subsequent operations.\n * \n * @param name Name of the audio device to find\n * \n * @return Returns audio device handle, or NULL if not found.\n */\nTDL_AUDIO_HANDLE_T tdl_audio_find(const char *name);\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"device-open-interface",children:"Device Open Interface"}),"\n",(0,a.jsx)(n.p,{children:"This interface opens and initializes the audio device, including hardware initialization, pin configuration, and other operations, to make the device available."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"/**\n * @brief Opens and initializes an audio device.\n * \n * This function opens the specified audio device and initializes audio hardware \n * including ADC/DAC, I2S interface, speaker enable pins, etc. After successful \n * opening, the device enters a usable state.\n * \n * @param audio_hdl Audio device handle\n * \n * @return Returns OPRT_OK on successful opening, or an appropriate error code on failure.\n */\nOPERATE_RET tdl_audio_open(TDL_AUDIO_HANDLE_T audio_hdl);\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"device-close-interface",children:"Device Close Interface"}),"\n",(0,a.jsx)(n.p,{children:"This interface closes the audio device and releases related resources, including de-initializing the hardware and disabling pins."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"/**\n * @brief Closes and deinitializes an audio device.\n * \n * This function closes the specified audio device and deinitializes audio hardware \n * including releasing I2S resources, disabling speaker pins, closing ADC/DAC, etc. \n * After closing, the device becomes unavailable and needs to be reopened for use.\n * \n * @param audio_hdl Audio device handle\n * \n * @return Returns OPRT_OK on successful closing, or an appropriate error code on failure.\n */\nOPERATE_RET tdl_audio_close(TDL_AUDIO_HANDLE_T audio_hdl);\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"volume-adjustment-interface",children:"Volume Adjustment Interface"}),"\n",(0,a.jsx)(n.p,{children:"This interface is used to dynamically adjust the audio output volume and control the gain of the speaker power amplifier."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"/**\n * @brief Sets audio output volume.\n * \n * This function adjusts the output volume of the audio device, controls the gain \n * of the speaker amplifier, and implements dynamic volume adjustment functionality.\n * \n * @param audio_hdl Audio device handle\n * @param volume Volume value, typically ranging from 0-100\n * \n * @return Returns OPRT_OK on successful setting, or an appropriate error code on failure.\n */\nOPERATE_RET tdl_audio_volume_set(TDL_AUDIO_HANDLE_T audio_hdl, uint8_t volume);\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"audio-playback-control-interface",children:"Audio Playback Control Interface"}),"\n",(0,a.jsx)(n.p,{children:"This interface is used to play audio data, outputting audio frames to the speaker through the hardware interface."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"/**\n * @brief Plays audio data.\n * \n * This function sends audio frame data to the audio device for playback. Data is \n * output to the speaker through DAC or I2S interface. Supports different audio \n * frame formats.\n * \n * @param audio_hdl Audio device handle\n * @param frame_data Audio frame data pointer\n * @param frame_size Audio frame data size\n * @param format Audio frame format\n * \n * @return Returns OPRT_OK on successful playback, or an appropriate error code on failure.\n */\nOPERATE_RET tdl_audio_play(TDL_AUDIO_HANDLE_T audio_hdl, void *frame_data, uint32_t frame_size,\n                           TDL_AUDIO_FRAME_FORMAT_E format);\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"audio-stop-playback-interface",children:"Audio Stop Playback Interface"}),"\n",(0,a.jsx)(n.p,{children:"This interface is used to stop the current audio playback, turn off the audio output, and put the device into a mute state."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"/**\n * @brief Stops audio playback.\n * \n * This function stops the currently ongoing audio playback, closes audio output, \n * disables speaker amplifier, and puts the device into a mute state.\n * \n * @param audio_hdl Audio device handle\n * \n * @return Returns OPRT_OK on successful stopping, or an appropriate error code on failure.\n */\nOPERATE_RET tdl_audio_play_stop(TDL_AUDIO_HANDLE_T audio_hdl);\n\n"})})]})}function u(e={}){let{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},31599:function(e,n,i){i.d(n,{A:()=>t});let t=i.p+"assets/images/open_audio-c2c194ce0d4a362f5128872aaafb961b.png"},84429:function(e,n,i){i.d(n,{R:()=>d,x:()=>o});var t=i(96540);let a={},r=t.createContext(a);function d(e){let n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:d(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);