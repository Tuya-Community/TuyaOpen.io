"use strict";(self.webpackChunktuyaopen_io_website=self.webpackChunktuyaopen_io_website||[]).push([["7589"],{6919(e,t,a){a.r(t),a.d(t,{metadata:()=>r,default:()=>u,frontMatter:()=>s,contentTitle:()=>l,toc:()=>o,assets:()=>d});var r=JSON.parse('{"id":"tkl-api/tkl_ota","title":"tkl_ota | OTA Firmware Update","description":"tkl_ota.c Over-the-Air (OTA) firmware update handles the various stages of the firmware update process: obtaining firmware update capability, OTA start notification, OTA data processing, and OTA end notification. This file is automatically generated by the TuyaOS and allows you to add your own implementations in the provided user-defined areas.","source":"@site/docs/tkl-api/tkl_ota.md","sourceDirName":"tkl-api","slug":"/tkl-api/tkl_ota","permalink":"/docs/tkl-api/tkl_ota","draft":false,"unlisted":false,"editUrl":"https://github.com/Tuya-Community/TuyaOpen.io/edit/master/docs/tkl-api/tkl_ota.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"tkl_wakeup | Wake-up Driver","permalink":"/docs/tkl-api/tkl_wakeup"},"next":{"title":"tkl_output | Log Output","permalink":"/docs/tkl-api/tkl_output"}}'),i=a(4848),n=a(8453);let s={},l="tkl_ota | OTA Firmware Update",d={},o=[{value:"API description",id:"api-description",level:2},{value:"tkl_ota_get_ability",id:"tkl_ota_get_ability",level:3},{value:"Features",id:"features",level:4},{value:"Parameters",id:"parameters",level:4},{value:"Return value",id:"return-value",level:4},{value:"tkl_ota_start_notify",id:"tkl_ota_start_notify",level:3},{value:"Features",id:"features-1",level:4},{value:"Parameters",id:"parameters-1",level:4},{value:"Return value",id:"return-value-1",level:4},{value:"tkl_ota_data_process",id:"tkl_ota_data_process",level:3},{value:"Features",id:"features-2",level:4},{value:"Parameters",id:"parameters-2",level:4},{value:"Return value",id:"return-value-2",level:4},{value:"tkl_ota_end_notify",id:"tkl_ota_end_notify",level:3},{value:"Features",id:"features-3",level:4},{value:"Parameters",id:"parameters-3",level:4},{value:"Return value",id:"return-value-3",level:4},{value:"tkl_ota_get_old_firmware_info",id:"tkl_ota_get_old_firmware_info",level:3},{value:"Features",id:"features-4",level:4},{value:"Parameters",id:"parameters-4",level:4},{value:"Return value",id:"return-value-4",level:4}];function c(e){let t={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,n.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"tkl_ota--ota-firmware-update",children:"tkl_ota | OTA Firmware Update"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"tkl_ota.c"})," Over-the-Air (OTA) firmware update handles the various stages of the firmware update process: obtaining firmware update capability, OTA start notification, OTA data processing, and OTA end notification. This file is automatically generated by the TuyaOS and allows you to add your own implementations in the provided user-defined areas."]}),"\n",(0,i.jsx)(t.h2,{id:"api-description",children:"API description"}),"\n",(0,i.jsx)(t.h3,{id:"tkl_ota_get_ability",children:"tkl_ota_get_ability"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c",children:"OPERATE_RET tkl_ota_get_ability(uint32_t *image_size, TUYA_OTA_TYPE_E *type);\n"})}),"\n",(0,i.jsx)(t.h4,{id:"features",children:"Features"}),"\n",(0,i.jsx)(t.p,{children:"Gets the OTA capability information of the current device, including the maximum firmware image size and the OTA type."}),"\n",(0,i.jsx)(t.h4,{id:"parameters",children:"Parameters"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"image_size"}),": Output parameter, used to store the maximum size of the firmware image."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"type"}),": Output parameter, the OTA type. It can be a full package or a differential package. Use ",(0,i.jsx)(t.code,{children:"TUYA_OTA_FULL"})," for a full package and ",(0,i.jsx)(t.code,{children:"TUYA_OTA_DIFF"})," for a differential package.","\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c",children:"    typedef enum {\n        TUYA_OTA_FULL        = 1,            ///< AB area switch, full package update\n        TUYA_OTA_DIFF        = 2,            ///< fixed area, differential package update\n    } TUYA_OTA_TYPE_E;\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h4,{id:"return-value",children:"Return value"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"OPRT_OK"})," indicates success, while any other value indicates an error. For more information, see ",(0,i.jsx)(t.code,{children:"tuya_error_code.h"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"tkl_ota_start_notify",children:"tkl_ota_start_notify"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c",children:"OPERATE_RET tkl_ota_start_notify(uint32_t image_size, TUYA_OTA_TYPE_E type, TUYA_OTA_PATH_E path);\n"})}),"\n",(0,i.jsx)(t.h4,{id:"features-1",children:"Features"}),"\n",(0,i.jsx)(t.p,{children:"Notifies that an OTA update is starting. This function initializes the necessary variables and states for the OTA process."}),"\n",(0,i.jsx)(t.h4,{id:"parameters-1",children:"Parameters"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"image_size"}),": Input parameter, the size of the firmware image to be updated."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"type"}),": Input parameter, the OTA type."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"path"}),": Input parameter, the OTA path. It indicates the channel through which the data is transmitted.","\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c",children:"    typedef enum {\n    TUYA_OTA_PATH_AIR    = 0,            ///< OTA from Wired/Wi-Fi/Cellular/NBIoT\n    TUYA_OTA_PATH_UART   = 1,            ///< OTA from uart for MF\n    TUYA_OTA_PATH_BLE    = 2,            ///< OTA from BLE protocol for subdev\n    TUYA_OTA_PATH_ZIGBEE = 3,            ///< OTA from Zigbee protocol for subdev\n    TUYA_OTA_PATH_SEC_A = 4,             ///< OTA from multi-section A\n    TUYA_OTA_PATH_SEC_B = 5,             ///< OTA from multi-section B\n    TUYA_OTA_PATH_INVALID = 255          ///< OTA from multi-section invalid\n    }TUYA_OTA_PATH_E;\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h4,{id:"return-value-1",children:"Return value"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"OPRT_OK"})," indicates success, while any other value indicates an error. For more information, see ",(0,i.jsx)(t.code,{children:"tuya_error_code.h"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"tkl_ota_data_process",children:"tkl_ota_data_process"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c",children:"OPERATE_RET tkl_ota_data_process(TUYA_OTA_DATA_T *pack, uint32_t* remain_len);\n"})}),"\n",(0,i.jsx)(t.h4,{id:"features-2",children:"Features"}),"\n",(0,i.jsx)(t.p,{children:"Processes the received OTA data packet. This function performs different update operations depending on the state."}),"\n",(0,i.jsx)(t.h4,{id:"parameters-2",children:"Parameters"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"pack"}),": Input parameter, the pointer to the OTA data packet."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"remain_len"}),": Output parameter. Indicates the remaining unprocessed data length within the OTA data packet."]}),"\n"]}),"\n",(0,i.jsx)(t.h4,{id:"return-value-2",children:"Return value"}),"\n",(0,i.jsxs)(t.p,{children:["If the data packet is processed successfully, the return value is ",(0,i.jsx)(t.code,{children:"OPRT_OK"}),". Otherwise, an error code is returned. For more information, see ",(0,i.jsx)(t.code,{children:"tuya_error_code.h"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"tkl_ota_end_notify",children:"tkl_ota_end_notify"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c",children:"OPERATE_RET tkl_ota_end_notify(BOOL_T reset);\n"})}),"\n",(0,i.jsx)(t.h4,{id:"features-3",children:"Features"}),"\n",(0,i.jsx)(t.p,{children:"Notifies that the OTA update has ended. It performs verification and subsequent processing, and resets the device if necessary."}),"\n",(0,i.jsx)(t.h4,{id:"parameters-3",children:"Parameters"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"reset"}),": Input parameter. Indicates whether a device reset is required after the OTA update ends."]}),"\n"]}),"\n",(0,i.jsx)(t.h4,{id:"return-value-3",children:"Return value"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"OPRT_OK"})," is returned if the operation is successful. If verification fails or other causes lead to failure, an error code is returned. For more information, see ",(0,i.jsx)(t.code,{children:"tuya_error_code.h"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"tkl_ota_get_old_firmware_info",children:"tkl_ota_get_old_firmware_info"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c",children:"OPERATE_RET tkl_ota_get_old_firmware_info(TUYA_OTA_FIRMWARE_INFO_T **info);\n"})}),"\n",(0,i.jsx)(t.h4,{id:"features-4",children:"Features"}),"\n",(0,i.jsx)(t.p,{children:"Gets information about the old firmware. This function is typically used for resumable transfer scenarios."}),"\n",(0,i.jsx)(t.h4,{id:"parameters-4",children:"Parameters"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"info"}),": Output parameter, the pointer to the old firmware information structure."]}),"\n"]}),"\n",(0,i.jsx)(t.h4,{id:"return-value-4",children:"Return value"}),"\n",(0,i.jsxs)(t.p,{children:["If the old firmware information is successfully obtained, the return value is ",(0,i.jsx)(t.code,{children:"OPRT_OK"}),". Otherwise, an error code is returned. For more information, see ",(0,i.jsx)(t.code,{children:"tuya_error_code.h"}),"."]})]})}function u(e={}){let{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453(e,t,a){a.d(t,{R:()=>s,x:()=>l});var r=a(6540);let i={},n=r.createContext(i);function s(e){let t=r.useContext(n);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(n.Provider,{value:t},e.children)}}}]);